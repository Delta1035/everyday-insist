[参考 yangwanging 解答](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/133)

1. let、const 执行机制分析(2020.01.18)
   > 猜测：可以通过两种现象来猜测：暂时死区、不允许重复变量。那么说 let、const 会有自己的执行机制统一来进行检查。(感觉自己的基础好差，低落)

- 解答：
  1. 声明过程
  - `var`：`var` 定义的变量在其他语句执行之前，已经完成了声明和初始化，但并未完成赋值(变量提升值为 `undefined`)
  - `function`：声明、初始化、赋值全部完成，函数的变量提升优先级更高
  - `let`：当解析器进入块级作用域时，发现 `let`，首先会声明，未初始化，此时调用 `let`，会抛出`Uncaught ReferenceError: Cannot access 'a' before initialization at ...`，也就是暂时死区。等到解析到 `let` 一行时，会发生初始化。(如果为赋值操作，初始化加赋值)
  2. 内存分配
  - `var`：栈内存里预分配内存空间，等实际执行时再分配变量，如果为引用类型，会在堆内存中开辟空间存储内容，栈内存空间存储指向堆内存的指针。
  - `let`：不会在栈内存预分配空间，当栈内存分配变量时，会做检查，存在同名变量，报错。
  - `const`：不会在栈内存预分配空间，但是栈内存存取的变量不可更改(引用类型地址不可更改)
  3. 变量提升：
  - `var`：声明、初始化提升
  - `let/cosnt`：声明提升
  - `function`：声明、初始化、赋值提升
